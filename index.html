<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">






  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/HTML5-知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kowal$ki">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/14/HTML5-知识点/" class="post-title-link" itemprop="http://yoursite.com/index.html">HTML5 知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-14 10:44:49 / Modified: 10:47:46" itemprop="dateCreated datePublished" datetime="2018-12-14T10:44:49+08:00">2018-12-14</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="HTML-语义化"><a href="#HTML-语义化" class="headerlink" title="HTML 语义化"></a>HTML 语义化</h2><ul>
<li>语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</li>
</ul>
<h2 id="localStorage、sessionStorage、cookies-的区别"><a href="#localStorage、sessionStorage、cookies-的区别" class="headerlink" title="localStorage、sessionStorage、cookies 的区别"></a>localStorage、sessionStorage、cookies 的区别</h2><p><code>localStorage</code> 本地存储，长期存在，大小一般为 5Mb，同源策略，因此可以用来跨页面交互数据</p>
<p><code>sessionStorage</code> 同上，但关闭浏览器就会消失</p>
<ul>
<li>常用的一些属性，方法：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Storage.length <span class="comment">// 返回一个整数，数据项数量</span></span><br><span class="line">Storage.setItem(key, value) <span class="comment">// 储存 / 更新</span></span><br><span class="line">Storage.getItem(key) <span class="comment">// 读取</span></span><br><span class="line">Storage.removeItem(key) <span class="comment">// 删除</span></span><br><span class="line">Storage.clear() <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure>
<p><code>cookies</code> 服务器发送到用户浏览器，并且保存在浏览器上的一块数据，会在下次发送请求时携带，并发送给服务器。</p>
<ul>
<li>有两种 <code>cookies</code>, <code>session cookies</code> 和 <code>persistent cookies</code>, <code>persistent cookies</code> 可以设置过期时间 <code>Expires</code> 或者有效期 <code>Max-Age</code></li>
<li><code>session cookies</code> 和 <code>persistent cookies</code> 的<a href="https://www.cisco.com/c/en/us/support/docs/security/web-security-appliance/117925-technote-csc-00.html" target="_blank" rel="noopener">对比</a>写的很清楚：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Types of Cookies</span><br><span class="line">There are two different types of cookies - session cookies and persistent cookies. If a cookie does not contain an expiration date, it is considered a session cookie. Session cookies are stored in memory and never written to disk. When the browser closes, the cookie is permanently lost from this point on. If the cookie contains an expiration date, it is considered a persistent cookie. On the date specified in the expiration, the cookie will be removed from the disk.</span><br></pre></td></tr></table></figure>
<ul>
<li>可以设置作用域 <code>domain</code>, 路径 <code>path</code></li>
<li><code>secure</code> 标记 <code>https</code> 协议传输</li>
<li>大小为 4kb</li>
<li>使用方法：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"yummy_cookie=choco"</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"tasty_cookie=strawberry"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/CSS-知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kowal$ki">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/14/CSS-知识点/" class="post-title-link" itemprop="http://yoursite.com/index.html">CSS 知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-14 10:44:49 / Modified: 10:47:08" itemprop="dateCreated datePublished" datetime="2018-12-14T10:44:49+08:00">2018-12-14</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSS-部分"><a href="#CSS-部分" class="headerlink" title="CSS 部分"></a>CSS 部分</h1><h2 id="px-em-rem-的区别"><a href="#px-em-rem-的区别" class="headerlink" title="px em rem 的区别"></a>px em rem 的区别</h2><ul>
<li><code>px</code> 是像素，绝对单位</li>
<li><code>em</code> 是相对长度单位，相对于当前对象内文本的字体尺寸。如果未对当前行内文本的字体尺寸进行设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。</li>
<li><code>rem</code> 是CSS3新增的一个相对单位（root em，根em），使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。</li>
<li>总结：<code>rem</code> 最优秀，通过它既可以做到只修改根元素字体大小就可以成比例的调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</li>
</ul>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ul>
<li>children 宽度确定</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">children</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex 方法1：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justity-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex 方法2：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">children</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute</span><br><span class="line">    left: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">trnasform</span>: <span class="built_in">translateX</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><ul>
<li>单行文本居中，<code>line-height</code> 与 <code>div</code> 高度保持一样就行了。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex 方法</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">children</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute</span><br><span class="line">    top: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">trnasform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p><code>position</code> 用于网页元素的定位，可设置 <code>static</code>/<code>relative</code>/<code>absolute</code>/<code>fixed</code> 这些值，其中 <code>static</code> 是默认值，不用介绍。</p>
<h3 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a>定位上下文</h3><p><code>relative</code> 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</p>
<p><img src="https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/relative_position.png" alt="relative_position.png"></p>
<p><code>fixed</code> 元素的定位是相对于 <code>window</code> （或者 <code>iframe</code>）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p>
<p><img src="https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/fixed_position.png" alt="fixed_position.png"></p>
<p><code>absolute</code> 的定位相对于前两者要复杂许多。如果为 <code>absolute</code> 设置了 <code>top</code>、<code>left</code>，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了 <code>position</code>: <code>relative</code> / <code>absolute</code> / <code>fixed</code> 的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</p>
<p><img src="https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/absolute_position_1.png" alt="absolute_position_1.png"></p>
<p><img src="https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/absolute_position_2.png" alt="absolute_position_2.png"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul>
<li>两栏布局</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:left; width:200px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-left: 200px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>三栏布局</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:left; width:200px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:right; width:200px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-left: 200px; margin-right: 200px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>flex 布局</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">参考链接</a></p>
<h2 id="float-相关"><a href="#float-相关" class="headerlink" title="float 相关"></a>float 相关</h2><ul>
<li><code>float</code> 定义：指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动中移除，但仍然保持部分的流动性（与 <code>absolute</code> 相反）。</li>
</ul>
<h3 id="清除浮动方法："><a href="#清除浮动方法：" class="headerlink" title="清除浮动方法："></a>清除浮动方法：</h3><p><a href="https://github.com/wangwenyue/CSS-me/blob/master/example/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.html" target="_blank" rel="noopener">详见</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="margin-合并"><a href="#margin-合并" class="headerlink" title="margin 合并"></a>margin 合并</h2><ul>
<li>相邻的两个块级元素，间距是两者 <code>margin</code> 的最大值。</li>
<li>父子两个块级元素： 若第一个子元素的 <code>top</code> 上没有 <code>border</code> 或者 <code>padding</code> ,上方没有 <code>inlineBlock</code> 清除浮动的话，那么父子两元素的 <code>margin</code> 将合并，取两者的最大值。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/React-知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kowal$ki">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/14/React-知识点/" class="post-title-link" itemprop="http://yoursite.com/index.html">React 知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-14 10:44:49 / Modified: 10:47:20" itemprop="dateCreated datePublished" datetime="2018-12-14T10:44:49+08:00">2018-12-14</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="React-的基础原则"><a href="#React-的基础原则" class="headerlink" title="React 的基础原则"></a>React 的基础原则</h2><ol>
<li>React 界面完全由数据驱动；</li>
<li>React 中一切都是组件；</li>
<li><code>props</code> 是 React 组件之间通讯的基本方式。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = f(data)</span><br></pre></td></tr></table></figure>
<p>等号左边的 UI 代表最终画出来的界面；等号右边的 f 是一个函数，也就是我们写的 React 相关代码；data 就是数据，在 React 中，data 可以是 <code>state</code> 或者 <code>props</code>。</p>
<h2 id="组件：React-世界的一等公民"><a href="#组件：React-世界的一等公民" class="headerlink" title="组件：React 世界的一等公民"></a>组件：React 世界的一等公民</h2><ol>
<li>用户界面就是组件；</li>
<li>组件可以嵌套包装组成复杂功能；</li>
<li>组件可以用来实现副作用。</li>
</ol>
<p>在 React 中，一个组件可以是一个类，也可以是一个函数，这取决于这个组件是否有自己的状态。</p>
<h2 id="React-组件设计原则"><a href="#React-组件设计原则" class="headerlink" title="React 组件设计原则"></a>React 组件设计原则</h2><ol>
<li>保持接口小，<code>props</code> 数量要少；</li>
<li>根据数据边界来划分组件，充分利用组合（composition）；</li>
<li>把 <code>state</code> 往上层组件提取，让下层组件只需要实现为纯函数。</li>
</ol>
<h2 id="重用组件逻辑的方式"><a href="#重用组件逻辑的方式" class="headerlink" title="重用组件逻辑的方式"></a>重用组件逻辑的方式</h2><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p>在开发 React 组件过程中，很容易发现这样一种现象，某些功能是多个组件通用的，如果每个组件都重复实现这样的逻辑，肯定十分浪费，而且违反了“不要重复自己”（DRY，Don’t Repeat Yourself)的编码原则，我们肯定想要把这部分共用逻辑提取出来重用。</p>
<p>我们说过，在 React 的世界里，组件是第一公民，首先想到的是当然是把共用逻辑提取为一个 React 组件。不过，有些情况下，这些共用逻辑还没法成为一个独立组件，换句话说，这些共用逻辑单独无法使用，它们只是对其他组件的功能加强。</p>
<p>举个例子，对于很多网站应用，有些模块都需要在用户已经登录的情况下才显示。比如，对于一个电商类网站，“退出登录”按钮、“购物车”这些模块，就只有用户登录之后才显示，对应这些模块的 React 组件如果连“只有在登录时才显示”的功能都重复实现，那就浪费了。</p>
<p>这时候，我们就可以利用“高阶组件（HoC）”这种模式来解决问题。</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>render props 其实就是 React 世界中的“依赖注入”（Dependency Injection)。</p>
<p>所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A。</p>
<h3 id="render-props-和高阶组件的比较"><a href="#render-props-和高阶组件的比较" class="headerlink" title="render props 和高阶组件的比较"></a>render props 和高阶组件的比较</h3><p>当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。</p>
<h2 id="提供者模式"><a href="#提供者模式" class="headerlink" title="提供者模式"></a>提供者模式</h2><p>在 React 中，<code>props</code> 是组件之间通讯的主要手段，但是，有一种场景单纯靠 <code>props</code> 来通讯是不恰当的，那就是两个组件之间间隔着多层其他组件，下面是一个简单的组件树示例图:</p>
<p><img src="https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/react_msg_props.png" alt="react_msg_props.png"></p>
<p>在上图中，组件 <code>A</code> 需要传递信息给组件 <code>X</code>，如果通过 <code>props</code> 的话，那么从顶部的组件 <code>A</code> 开始，要把 <code>props</code> 传递给组件 <code>B</code>，然后组件 <code>B</code> 传递给组件 <code>D</code>，最后组件 <code>D</code> 再传递给组件 <code>X</code>。</p>
<p>其实组件 <code>B</code> 和组件 <code>D</code> 完全用不上这些 <code>props</code>，但是又被迫传递这些 <code>props</code>，这明显不合理，要知道组件树的结构会变化的，将来如果组件 <code>B</code> 和组件 <code>D</code> 之间再插入一层新的组件，这个组件也需要传递这个 <code>props</code>，这就麻烦无比。</p>
<p>可见，对于跨级的信息传递，我们需要一个更好的方法。</p>
<p>在 React 中，解决这个问题应用的就是“提供者模式”。</p>
<h2 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = f(data)</span><br></pre></td></tr></table></figure>
<p>f 的参数 data，除了 <code>props</code>，就是 <code>state</code>。<code>props</code> 是组件外传递进来的数据，<code>state</code> 代表的就是 React 组件的内部状态。</p>
<p>对于 React 组件而言，数据分为两种：</p>
<ol>
<li><code>props</code></li>
<li><code>state</code></li>
</ol>
<p>二者的区别显而易见，简单说就是，<code>props</code> 是外部传给组件的数据，而 <code>state</code> 是组件自己维护的数据，对外部是不可见的。</p>
<p>所以，判断某个数据以 <code>props</code> 方式存在，还是以 <code>state</code> 方式存在，并不难，只需要判断这个状态是否是组件内部状态。</p>
<p>判断一个数据应该放在哪里，用下面的原则：</p>
<ol>
<li>如果数据由外部传入，放在 <code>props</code> 中；</li>
<li>如果是组件内部状态，是否这个状态更改应该立刻引发一次组件重新渲染？如果是，放在 <code>state</code> 中；不是，放在成员变量中。</li>
</ol>
<h2 id="React-的未来"><a href="#React-的未来" class="headerlink" title="React 的未来"></a>React 的未来</h2><h3 id="同步渲染的问题"><a href="#同步渲染的问题" class="headerlink" title="同步渲染的问题"></a>同步渲染的问题</h3><p>React 最初的设计，整个渲染过程都是同步的。同步的意思是，当一个组件开始渲染之后，就必须一口气渲染完，不能中断，对于特别庞大的组件树，这个渲染过程会很耗时，而且，这种同步处理，也会导致我们的代码比较麻烦。</p>
<p>假设有一个超大的 React 组件树结构，有 1000 个组件，每个组件平均使用 1 毫秒，那么，要做一次完整的渲染就要花费 1000 毫秒也就是 1 秒钟，然而 JavaScript 运行环境是单线程的，也就是说，React 用同步渲染方式，渲染最根部组件的时候，会同步引发渲染子组件，再同步渲染子组件的子组件……最后完成整个组件树。在这 1 秒钟内，同步渲染霸占 JavaScript 唯一的线程，其他的操作什么都做不了，在这 1 秒钟内，如果用户要点击什么按钮，或者在某个输入框里面按键，都不会看到立即的界面反应，这也就是俗话说的“卡顿”。</p>
<p>在同步渲染下，要解决“卡顿”的问题，只能是尽量缩小组件树的大小，以此缩短渲染时间，但是，应用的规模总是在增大的，不是说缩小就能缩小的，虽然我们利用定义 <code>shouldComponentUpdate</code> 的方法可以减少不必要的渲染，但是这也无法从根本上解决大量同步渲染带来的“卡顿”问题。</p>
<h3 id="异步渲染"><a href="#异步渲染" class="headerlink" title="异步渲染"></a>异步渲染</h3><p><code>React Fiber</code> 引入了异步渲染，有了异步渲染之后，React 组件的渲染过程是分时间片的，不是一口气从头到尾把子组件全部渲染完，而是每个时间片渲染一点，然后每个时间片的间隔都可去看看有没有更紧急的任务（比如用户按键），如果有，就去处理紧急任务，如果没有那就继续照常渲染。</p>
<p><code>React v16.3</code> 之前的完整的生命周期函数图：</p>
<p><img src="https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/before_16_3.png" alt="before_16_3.png"></p>
<p>为什么不在 <code>componentWillMount</code> 里去做 <code>AJAX</code>？<code>componentWillMount</code> 可是比 <code>componentDidMount</code> 更早调用啊，更早调用意味着更早返回结果，那样性能不是更高吗？</p>
<p>首先，一个组件的 <code>componentWillMount</code> 比 <code>componentDidMount</code> 也早调用不了几微秒，性能没啥提高；而且，等到异步渲染开启的时候，<code>componentWillMount</code> 就可能被中途打断，中断之后渲染又要重做一遍，想一想，在 <code>componentWillMount</code> 中做 <code>AJAX</code> 调用，代码里看到只有调用一次，但是实际上可能调用 N 多次，这明显不合适。相反，若把 <code>AJAX</code> 放在 <code>componentDidMount</code>，因为 <code>componentDidMount</code> 在第二阶段，所以绝对不会多次重复调用，这才是 <code>AJAX</code> 合适的位置。</p>
<p><code>React v16.3</code> 之后的完整的生命周期函数图：</p>
<p><img src="https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/after_16_3.png" alt="after_16_3.png"></p>
<h3 id="Suspense-带来的异步操作革命"><a href="#Suspense-带来的异步操作革命" class="headerlink" title="Suspense 带来的异步操作革命"></a><code>Suspense</code> 带来的异步操作革命</h3><p><code>Suspense</code> 应用的场合就是异步数据处理，最常见的例子，就是通过 <code>AJAX</code> 从服务器获取数据，每一个 React 开发者都曾为这个问题纠结。</p>
<p>如果用一句话概括 <code>Suspense</code> 的功用，那就是：<strong>用同步的代码来实现异步操作</strong>。</p>
<h3 id="函数化的-Hooks"><a href="#函数化的-Hooks" class="headerlink" title="函数化的 Hooks"></a>函数化的 <code>Hooks</code></h3><p><strong><code>Hooks</code> 的目的，简而言之就是让开发者不需要再用 <code>class</code> 来实现组件。</strong></p>
<p><code>useState</code> 只接受一个参数，也就是 <code>state</code> 的初始值，它返回一个只有两个元素的数组，第一个元素就是 <code>state</code> 的值，第二个元素是更新 <code>state</code> 的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>useEffect</code>，用于支持组件中增加副作用的支持。</p>
<p><code>useEffect</code> 的参数是一个函数，组件每次渲染之后，都会调用这个函数参数，这样就达到了 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 一样的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">document</span>.title = <span class="string">`Count: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>虽然本质上，依然是 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 两个生命周期被调用，但是现在我们关心的不是 <code>mount</code> 或者 <code>update</code> 过程，而是“after render”事件，<code>useEffect</code> 就是告诉组件在“渲染完”之后做点什么事。</p>
<p>现在把 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 混在了一起，那假如某个场景下我只在 <code>mount</code> 时做事但 <code>update</code> 不做事，用 <code>useEffect</code> 不就不行了吗？</p>
<p>其实，用一点小技巧就可以解决。<code>useEffect</code> 还支持第二个可选参数，只有同一 <code>useEffect</code> 的两次调用第二个参数不同时，第一个函数参数才会被调用，所以，如果想模拟 <code>componentDidMount</code>，只需要这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里只有mount时才被调用，相当于componentDidMount</span></span><br><span class="line">&#125;, [<span class="number">123</span>])</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>useEffect</code> 的第二个参数是 <code>[123]</code>，其实也可以是任何一个常数，因为它永远不变，所以 <code>useEffect</code> 只在 <code>mount</code> 时调用第一个函数参数一次，达到了 <code>componentDidMount</code> 一样的效果。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/Throttle_debounce/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kowal$ki">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/14/Throttle_debounce/" class="post-title-link" itemprop="http://yoursite.com/index.html">“节流”与“防抖”</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-14 10:44:49 / Modified: 10:47:42" itemprop="dateCreated datePublished" datetime="2018-12-14T10:44:49+08:00">2018-12-14</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="“节流”与“防抖”的本质"><a href="#“节流”与“防抖”的本质" class="headerlink" title="“节流”与“防抖”的本质"></a>“节流”与“防抖”的本质</h1><p>这两个东西都以闭包的形式存在。</p>
<p>它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。</p>
<h1 id="Throttle：-第一个人说了算"><a href="#Throttle：-第一个人说了算" class="headerlink" title="Throttle： 第一个人说了算"></a>Throttle： 第一个人说了算</h1><p>throttle 的中心思想在于：在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</p>
<p>先给大家讲个小故事：现在有一个旅客刚下了飞机，需要用车，于是打电话叫了该机场唯一的一辆机场大巴来接。司机开到机场，心想来都来了，多接几个人一起走吧，这样这趟才跑得值——我等个十分钟看看。于是司机一边打开了计时器，一边招呼后面的客人陆陆续续上车。在这十分钟内，后面下飞机的乘客都只能乘这一辆大巴，十分钟过去后，不管后面还有多少没挤上车的乘客，这班车都必须发走。</p>
<p>在这个故事里，“司机” 就是我们的节流阀，他控制发车的时机；“乘客”就是因为我们频繁操作事件而不断涌入的回调任务，它需要接受“司机”的安排；而“计时器”，就是我们上文提到的以自由变量形式存在的时间信息，它是“司机”决定发车的依据；最后“发车”这个动作，就对应到回调函数的执行。</p>
<p>总结下来，所谓的“节流”，是通过在一段时间内无视后来产生的回调请求来实现的。只要一位客人叫了车，司机就会为他开启计时器，一定的时间内，后面需要乘车的客人都得排队上这一辆车，谁也无法叫到更多的车。</p>
<p>对应到实际的交互上是一样一样的：每当用户触发了一次 scroll 事件，我们就为这个触发操作开启计时器。一段时间内，后续所有的 scroll 事件都会被当作“一辆车的乘客”——它们无法触发新的 scroll 回调。直到“一段时间”到了，第一次触发的 scroll 事件对应的回调才会执行，而“一段时间内”触发的后续的 scroll 回调都会被节流阀无视掉。</p>
<p>理解了大致的思路，我们现在一起实现一个 throttle：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, interval是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">      <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">      <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">      <span class="keyword">if</span> (now - last &gt;= interval) &#123;</span><br><span class="line">      <span class="comment">// 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span></span><br><span class="line">          last = now;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用throttle来包装scroll的回调</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'触发了滚动事件'</span>), <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<h1 id="Debounce：-最后一个人说了算"><a href="#Debounce：-最后一个人说了算" class="headerlink" title="Debounce： 最后一个人说了算"></a>Debounce： 最后一个人说了算</h1><p>防抖的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。</p>
<p>继续讲司机开车的故事。这次的司机比较有耐心。第一个乘客上车后，司机开始计时（比如说十分钟）。十分钟之内，如果又上来了一个乘客，司机会把计时器清零，重新开始等另一个十分钟（延迟了等待）。直到有这么一位乘客，从他上车开始，后续十分钟都没有新乘客上车，司机会认为确实没有人需要搭这趟车了，才会把车开走。</p>
<p>我们对比 throttle 来理解 debounce：在throttle的逻辑里，“第一个人说了算”，它只为第一个乘客计时，时间到了就执行回调。而 debounce 认为，“最后一个人说了算”，debounce 会为每一个新乘客设定新的定时器。</p>
<p>我们基于上面的理解，一起来写一个 debounce：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将debounce处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次事件被触发时，都去清除之前的旧定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设立新定时器</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用debounce来包装scroll的回调</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, debounce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'触发了滚动事件'</span>), <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/HTTP-知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kowal$ki">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/14/HTTP-知识点/" class="post-title-link" itemprop="http://yoursite.com/index.html">HTTP 知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-14 10:43:33 / Modified: 10:44:26" itemprop="dateCreated datePublished" datetime="2018-12-14T10:43:33+08:00">2018-12-14</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h2><ul>
<li>GET 获取</li>
<li>POST 提交</li>
<li>PUT 替换取代</li>
<li>DELETE 删除</li>
<li>OPTIONS 预检请求 检查是否符合post等请求的条件</li>
</ul>
<h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><ul>
<li>1xx 代表请求已被接受，需要继续处理<ul>
<li>100 Continue 已接收到请求头</li>
<li>101 服务器已理解，但需要切换协议</li>
<li>102 Processing 服务器已经收到并在处理，但暂无相应可用</li>
</ul>
</li>
<li>2xx 请求成功，服务器接收、理解、并接受<ul>
<li><strong>200 OK 请求已成功</strong></li>
<li>202 Accepted 服务器已接收，但尚未处理，也可能不会执行</li>
<li>204 No Content 成功处理，但是没有任何返回内容</li>
</ul>
</li>
<li>3xx 重定向<ul>
<li><strong>301 被请求的资源已经永久移动到新位置</strong></li>
<li><strong>302 Found 要求客户端执行临时重定向</strong></li>
<li>304 表示资源未被修改，不重新传输</li>
<li>305 需要使用代理才可以访问</li>
</ul>
</li>
<li>4xx 客户端错误<ul>
<li>400 错误请求，服务器不能或者不会处理</li>
<li>401 未认证，用户没有必要的凭据</li>
<li><strong>403 访问被拒绝</strong></li>
<li><strong>404 请求失败，资源未在服务器上发现</strong></li>
<li>405 请求方法不能用于获取请求的资源</li>
<li>408 请求超时</li>
</ul>
</li>
<li>5xx 服务器错误<ul>
<li>500 通用错误，但是没有错误信息</li>
<li>501 服务器不支持</li>
<li><strong>502 Bad Gateway 网关或者代理的服务器执行请求时，从上游服务器接收到无效的响应</strong></li>
<li><strong>504 Gateway Timeout 网关超时</strong></li>
</ul>
</li>
</ul>
<h2 id="头部常见字段"><a href="#头部常见字段" class="headerlink" title="头部常见字段"></a>头部常见字段</h2><ul>
<li>Accept 期望的 MIME 类型列表</li>
<li>Accept-Charset 期望的字符集</li>
<li>Accept-Encoding 支持的压缩方法</li>
<li>Connection</li>
<li><strong>Content-Length 请求长度</strong></li>
<li><strong>Content-Type 内容类型</strong></li>
<li><strong>Host 服务器</strong></li>
<li>Origin 访问的地址</li>
<li>Referer 来自</li>
<li>User-Agent</li>
<li>Accept-Language 期望的页面语言</li>
<li><strong>Request Method 请求方法</strong></li>
</ul>
<h1 id="跨域（jsonp-postMessage-cors-用服务器-比如-node-转发请求和响应）"><a href="#跨域（jsonp-postMessage-cors-用服务器-比如-node-转发请求和响应）" class="headerlink" title="跨域（jsonp, postMessage, cors, 用服务器(比如 node)转发请求和响应）"></a>跨域（jsonp, postMessage, cors, 用服务器(比如 node)转发请求和响应）</h1><h2 id="跨域有哪些常见的解决方式"><a href="#跨域有哪些常见的解决方式" class="headerlink" title="跨域有哪些常见的解决方式"></a>跨域有哪些常见的解决方式</h2><ul>
<li><code>cors</code> 设置被跨域服务器，可以接受来自 a.com 的请求（其实是允许某个地址可以访问）</li>
<li><code>jsonp</code> ，用 script src 去引用，获取信息</li>
<li>架设 <code>node</code> 本地转发请求，或者请求后端转发请求 （这个不是很了解）</li>
</ul>
<h2 id="XSS-跨网站指令码-Cross-site-scripting"><a href="#XSS-跨网站指令码-Cross-site-scripting" class="headerlink" title="XSS  跨网站指令码 Cross-site scripting"></a><code>XSS</code>  跨网站指令码 <code>Cross-site scripting</code></h2><p><code>XSS</code> 通过修改 <code>HTML</code> 节点或者执行 <code>JavaScript</code> 代码来攻击网站。</p>
<p>如何防御?</p>
<p>最普遍的做法是</p>
<ul>
<li>转义输入输出的内容，对于引号，尖括号，斜杠进行转义</li>
<li>白名单的方式。</li>
</ul>
<h2 id="CSRF-跨站请求伪造-Cross-site-request-forgery"><a href="#CSRF-跨站请求伪造-Cross-site-request-forgery" class="headerlink" title="CSRF 跨站请求伪造  Cross-site request forgery"></a><code>CSRF</code> 跨站请求伪造  <code>Cross-site request forgery</code></h2><p>利用用户的登录态发起恶意请求。</p>
<p>防范 <code>CSRF</code> 可以遵循以下几种规则：</p>
<ul>
<li><code>Get</code> 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 <code>Cookie</code></li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者 <code>token</code></li>
</ul>
<p><code>xss</code> 和 <code>xsrf</code> 的原理是什么<br><code>xss</code> 是 <code>html</code> 注入，用户在输入的地方插入 <code>script</code> 元素,浏览器会识别为 <code>JavaScript</code> 代码，如果这个代码有访问外部服务器，就是 <code>xss</code> 攻击<br>防治措施是 不信任用户的输入，将 &lt; &gt; 转译为 &lt; &rt; 来处理内容<br>csrf 是跨站攻击，拿到了用户的信息之后，伪造用户请求去访问接口</p>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p>在客户端浏览器中每个页面都有一个独立的窗口对象 <code>window</code>，默认情况下<code>window.name</code>为空，在窗口的生命周期中，载入的所有页面共享一个 <code>window.name</code> 并且每个页面都有对此读写的权限，<code>window.name</code> 会一直存在当前窗口，但存储的<code>字符串</code>不超过<code>2M</code>。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">window</span>.name</span><br><span class="line"><span class="string">""</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">window</span>.name=<span class="string">'test'</span>;</span><br><span class="line"><span class="string">"test"</span></span><br><span class="line"></span><br><span class="line">&gt; location.href=<span class="string">'http://www.google.com'</span>;</span><br><span class="line"><span class="string">"http://www.google.com"</span></span><br><span class="line">Navigated to https:<span class="comment">//www.google.com/</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">window</span>.name</span><br><span class="line"><span class="string">"test"</span></span><br></pre></td></tr></table></figure>
<h2 id="网址组成（四部分）"><a href="#网址组成（四部分）" class="headerlink" title="网址组成（四部分）"></a>网址组成（四部分）</h2><ul>
<li>协议     <code>http</code>, <code>https</code>（<code>https</code> 是加密的 <code>http</code>）</li>
<li>主机     <code>g.cn</code>  <code>zhihu.com</code>之类的网址</li>
<li>端口     <code>HTTP</code> 协议默认是 80，因此一般不用填写</li>
<li>路径     下面的「/」和「/question/31838184」都是路径</li>
</ul>
<p><code>http://www.zhihu.com/</code></p>
<p><code>http://www.zhihu.com/question/31838184</code></p>
<h2 id="端口是什么？"><a href="#端口是什么？" class="headerlink" title="端口是什么？"></a>端口是什么？</h2><p>一个比喻：<br>用邮局互相写信的时候，ip相当于地址（也可以看做邮编，地址是域名）<br>端口是收信人姓名（因为一个地址比如公司、家只有一个地址，但是却可能有很多收信人）<br>端口就是一个标记收信人的数字。<br>端口是一个 16 位(二进制的 位)的数字，所以范围是 0-65535（2**16）</p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>一个传输协议，协议就是双方都遵守的规范。<br>为什么叫超文本传输协议呢，因为收发的是文本信息。</p>
<ul>
<li>浏览器（客户端）按照规定的格式发送文本数据（请求）到服务器</li>
<li>服务器解析请求，按照规定的格式返回文本数据（响应）到浏览器</li>
<li>浏览器解析得到的数据，并做相应处理</li>
</ul>
<p>请求和返回是一样的数据格式，分为4部分：</p>
<ul>
<li>请求行或者响应行</li>
<li>Header（请求的 Header 中 Host 字段是必须的，其他都是可选）</li>
<li>\r\n\r\n（连续两个换行回车符，用来分隔Header和Body）</li>
<li>Body（可选）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: g.cn</span><br><span class="line"></span><br><span class="line">Body</span><br></pre></td></tr></table></figure>
<p>请求的格式，注意大小写（这是一个不包含Body的请求）：<br>原始数据如下</p>
<p><code>&#39;GET / HTTP/1.1\r\nhost:g.cn\r\n\r\n&#39;</code></p>
<p>打印出来如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: g.cn</span><br></pre></td></tr></table></figure>
<p><code>&#39;GET / HTTP/1.1\r\nhost: www.qq.com\r\n\r\n&#39;</code></p>
<p>其中</p>
<ul>
<li>GET 是请求方法（还有POST等，这就是个标志字符串而已）</li>
<li>/ 是请求的路径（这代表根路径）</li>
<li>HTTP/1.1  中，1.1是版本号，通用了20年</li>
</ul>
<p>具体字符串是 <code>&#39;GET / HTTP/1.1\r\nhost:g.cn\r\n\r\n&#39;</code><br>返回的数据如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Alternate-Protocol: 80:quic,p=0,80:quic,p=0</span><br><span class="line">Cache-Control: private, max-age=2592000</span><br><span class="line">Content-Length: 218</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Tue, 07 Jul 2015 02:57:59 GMT</span><br><span class="line">Expires: Tue, 07 Jul 2015 02:57:59 GMT</span><br><span class="line">Location: http://www.google.cn/</span><br><span class="line">Server: gws</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br></pre></td></tr></table></figure>
<p>Body部分略过<br>其中响应行（第一行）：</p>
<ul>
<li>HTTP/1.1 是版本</li>
<li>301 是「状态码」，参见文末链接</li>
<li>Moved Permanently 是状态码的描述</li>
</ul>
<p>浏览器会自己解析Header部分，然后将Body显示成网页</p>
<h2 id="从输入-URL-到页面加载完成的过程"><a href="#从输入-URL-到页面加载完成的过程" class="headerlink" title="从输入 URL 到页面加载完成的过程"></a>从输入 <code>URL</code> 到页面加载完成的过程</h2><p><a href="https://juejin.im/post/5bf3ad55f265da61682afc9b" target="_blank" rel="noopener">参考链接</a></p>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析:将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ol>
<h2 id="Ajax-过程："><a href="#Ajax-过程：" class="headerlink" title="Ajax 过程："></a>Ajax 过程：</h2><p>Ajax: 浏览器提供的使用 <code>HTTP</code> 协议收发数据的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 各代表什么含义</span><br><span class="line"></span><br><span class="line">0 代理被创建，但并未 open()</span><br><span class="line">1 已经调用 open()</span><br><span class="line">2 已经调用 send() 并且头部和状态已经获得了</span><br><span class="line">3 正在下载</span><br><span class="line">4 下载完成</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">method, path, data, responseCallback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 发送登录数据</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    <span class="comment">// 设置请求方法和请求地址</span></span><br><span class="line">    r.open(method, path, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 设置发送的数据的格式</span></span><br><span class="line">    r.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>)</span><br><span class="line">    <span class="comment">// 注册响应函数</span></span><br><span class="line">    r.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(r.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> response = <span class="built_in">JSON</span>.parse(r.response)</span><br><span class="line">            responseCallback(response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.send(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件冒泡-事件委托"><a href="#事件冒泡-事件委托" class="headerlink" title="事件冒泡, 事件委托"></a>事件冒泡, 事件委托</h2><p>事件触发有三个阶段</p>
<ul>
<li><code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li>
</ul>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下会先打印冒泡然后是捕获</span></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>, event =&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>, event =&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(<span class="string">'click'</span>, event =&gt;&#123;</span><br><span class="line">    event.stopImmediatePropagation()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'##ul'</span>)</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.target)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。</p>
<p>事件代理的方式相对于直接给目标注册事件来说，有以下优点:</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="优化原则和方向"><a href="#优化原则和方向" class="headerlink" title="优化原则和方向"></a>优化原则和方向</h3><p>性能优化的原则是以更好的用户体验为标准，具体就是实现下面的目标：</p>
<ol>
<li>多使用内存、缓存或者其他方法</li>
<li>减少 <code>CPU</code> 和 <code>GPU</code> 计算，更快展现</li>
</ol>
<p>优化的方向有两个：</p>
<ul>
<li>减少页面体积，提升网络加载</li>
<li>优化页面渲染</li>
</ul>
<h3 id="减少页面体积，提升网络加载"><a href="#减少页面体积，提升网络加载" class="headerlink" title="减少页面体积，提升网络加载"></a>减少页面体积，提升网络加载</h3><ul>
<li>静态资源的压缩合并（<code>JS</code> 代码压缩合并、<code>CSS</code> 代码压缩合并、雪碧图）</li>
<li>静态资源缓存（资源名称加 MD5 戳）</li>
<li>使用 <code>CDN</code> 让资源加载更快</li>
</ul>
<h3 id="优化页面渲染"><a href="#优化页面渲染" class="headerlink" title="优化页面渲染"></a>优化页面渲染</h3><ul>
<li><code>CSS</code> 放前面，<code>JS</code> 放后面</li>
<li>懒加载（图片懒加载、下拉加载更多）</li>
<li>减少 <code>DOM</code> 查询，对 <code>DOM</code> 查询做缓存</li>
<li>减少 <code>DOM</code> 操作，多个操作尽量合并在一起执行（DocumentFragment）</li>
<li>事件节流</li>
<li>尽早执行操作（DOMContentLoaded）</li>
<li>使用 <code>SSR</code> 后端渲染，数据直接输出到 <code>HTML</code> 中，减少浏览器使用 <code>JS</code> 模板渲染页面 <code>HTML</code> 的时间</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/JavaScript-知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kowal$ki">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/14/JavaScript-知识点/" class="post-title-link" itemprop="http://yoursite.com/index.html">JavaScript 知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-14 10:19:15 / Modified: 10:40:04" itemprop="dateCreated datePublished" datetime="2018-12-14T10:19:15+08:00">2018-12-14</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="值类型，引用类型"><a href="#值类型，引用类型" class="headerlink" title="值类型，引用类型"></a>值类型，引用类型</h2><ul>
<li>6大基本类型：<code>String</code>,  <code>Boolean</code> , <code>Number</code>,  <code>Null</code>, <code>Undefined</code> , <code>Symbol</code>, <code>Symbol</code> 用的比较少。<ul>
<li>基本类型的数据存在栈内存上。</li>
</ul>
</li>
<li>引用类型：<code>Object</code><ul>
<li>栈内存中保存了变量标识符和指向堆内存中该对象的指针。</li>
<li>堆内存保存了对象的值。</li>
</ul>
</li>
</ul>
<h2 id="深浅拷贝的问题"><a href="#深浅拷贝的问题" class="headerlink" title="深浅拷贝的问题"></a>深浅拷贝的问题</h2><p>解决问题的场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。<br>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。<a href="https://www.zhihu.com/question/23031215" target="_blank" rel="noopener">相关链接</a></p>
<h3 id="浅拷贝-shallow-copy"><a href="#浅拷贝-shallow-copy" class="headerlink" title="浅拷贝(shallow copy)"></a>浅拷贝(shallow copy)</h3><p>首先<code>深拷贝</code>和<code>浅拷贝</code>只针对像 <code>Object</code>, <code>Array</code> 这样的复杂对象的。<br>简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。<br><code>浅拷贝</code>一般用 <code>Object.assign</code> 或者扩展运算符 <code>...</code> 来解决。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>浅拷贝数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b.slice()</span><br><span class="line"><span class="keyword">var</span> a = b.concat([])</span><br></pre></td></tr></table></figure>
<p><a href="https://www.zhihu.com/question/56690271" target="_blank" rel="noopener">js slice 是不是浅拷贝？</a></p>
<h3 id="深拷贝-deep-copy"><a href="#深拷贝-deep-copy" class="headerlink" title="深拷贝(deep copy)"></a>深拷贝(deep copy)</h3><p>深拷贝一般用 JSON.parse(JSON.stringify(object)) 来解决。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure>
<h2 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a>闭包问题</h2><ul>
<li>闭包的定义：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 A 就被称为闭包。</li>
<li>闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</li>
<li>简单来说，闭包就是能够读取其他函数内部变量的函数。在Javascript中，只有函数内部的子函数才能读取函数的局部变量，所以，可以把闭包理解成：定义在一个函数内部的函数，也就是函数嵌套函数，给函数内部和函数外部搭建起一座桥梁。</li>
</ul>
<p><strong>闭包的作用</strong>： 闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。</p>
<ul>
<li>使用闭包实现如下程序: 函数每调用一次，该函数的返回值加 1。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)() <span class="comment">// a 就是个闭包</span></span><br><span class="line"></span><br><span class="line">a() <span class="comment">// 1</span></span><br><span class="line">a() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="comment">// var a</span></span><br><span class="line"><span class="comment">// console.log(a)</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b()) <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var b = function() &#123;return 2&#125;</span></span><br><span class="line"><span class="comment">// console.log(b())</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c()) <span class="comment">// c is not a function</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var c</span></span><br><span class="line"><span class="comment">// console.log(c())</span></span><br><span class="line"><span class="comment">// var c = function() &#123;return 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，let 或者 const 声明的变量不具备声明提升的特性</span></span><br><span class="line"><span class="built_in">console</span>.log(d)</span><br><span class="line"><span class="keyword">let</span> d = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">o.x = <span class="number">1</span></span><br><span class="line">o.m = test</span><br><span class="line">o.m.apply() <span class="comment">// 0 apply 需要指定一个 this，这里没给 apply 没给参数，则 this 指向了 window 所以 this.x 是 0</span></span><br><span class="line">o.m() <span class="comment">// 1 谁调用，指向谁</span></span><br><span class="line">o[<span class="string">'m'</span>]() <span class="comment">// 1</span></span><br><span class="line">o.m.apply() <span class="comment">//  0  相当于改变 this, 指向 window</span></span><br><span class="line"></span><br><span class="line">复杂的 <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gua = <span class="string">'name 001'</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="string">'0'</span>]())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">o.gua = <span class="string">'name 001'</span></span><br><span class="line">o.func = foo</span><br><span class="line"></span><br><span class="line">o.func(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.gua</span><br><span class="line">&#125;) <span class="comment">// undefined  this 指向 func 中的 argumets，但 arguments是个伪数组，其实是 Object, arguments 中没有 gua 这个字段，所以是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gua = <span class="string">'name 001'</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="string">'0'</span>]())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">o.gua = <span class="string">'name 001'</span></span><br><span class="line">o.func = foo</span><br><span class="line"></span><br><span class="line">o.func(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// f ()&#123;</span></span><br><span class="line"><span class="comment">// 	console.log(this)</span></span><br><span class="line"><span class="comment">//     return this['0']</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 arguments['0'] 是存在的, 即 func 的第一个参数</span></span><br><span class="line"></span><br><span class="line">o.func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>.gua = <span class="string">'gua'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.func2(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.gua</span><br><span class="line">&#125;) <span class="comment">// gua  此时，arguments.gua 是存在的</span></span><br><span class="line"><span class="comment">// 问题的关键在于搞清楚 this 的指向</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo() <span class="comment">// 1    这里 this 指向 window, 相当于 window.foo()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">// 2    obj 调用的 foo()，所以 this 指向 a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两者情况 this 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下情况是优先级最高的，this 只会绑定在 c 上，不会被任何方式修改 this 指向</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> foo()</span><br><span class="line">c.a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(c.a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new</span></span><br></pre></td></tr></table></figure>
<h2 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call, apply, bind 区别"></a><code>call</code>, <code>apply</code>, <code>bind</code> 区别</h2><p><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向, 并<strong>立即调用</strong>。<br>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。不传入第一个参数，那么默认为 <code>window</code>。<br><code>bind</code> 方法是 return 一个改写过 <code>this</code> 和参数的 <code>function</code>，这个 <code>function</code> 可以<strong>稍后调用</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call apply</span></span><br><span class="line">getValue.call(a, <span class="string">'Kowal$ki'</span>, <span class="string">'25'</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">'Kowal$ki'</span>, <span class="string">'25'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kowal$ki</span></span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 的用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>, <span class="string">'###'</span>) <span class="comment">// 将 console.log 绑定在 console 上面，返回的函数用 log 表示</span></span><br><span class="line">log(<span class="string">'hello'</span>) <span class="comment">// ### hello</span></span><br></pre></td></tr></table></figure>
<h2 id="简单的构造函数"><a href="#简单的构造函数" class="headerlink" title="简单的构造函数"></a>简单的构造函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'a'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo()</span><br><span class="line">f1.name = <span class="string">'b'</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.name) <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(f2.name) <span class="comment">// a</span></span><br></pre></td></tr></table></figure>
<h2 id="原型链-prototype"><a href="#原型链-prototype" class="headerlink" title="原型链 prototype"></a>原型链 <code>prototype</code></h2><p>继承时，JavaScript 只有一种结构：对象。<br>每个对象都有一个私有属性（称之为 [[Prototype]]），它持有一个连接到另一个称为其 <code>prototype</code> 对象（原型对象）的链接。<br>该 <code>prototype</code> 对象又具有一个自己的原型，层层向上直到一个对象的原型为 <code>null</code>。<br>根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</p>
<ul>
<li><p><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript继承机制的设计思想</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="noopener">Javascript 面向对象编程（一）：封装</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript面向对象编程（二）：构造函数的继承</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="noopener">Javascript面向对象编程（三）：非构造函数的继承</a></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'a'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.logName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name is'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo()</span><br><span class="line">f1.logName() <span class="comment">// name is a  没有修改原型 Foo 的 name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Foo()</span><br><span class="line">f2.logName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name'</span>)</span><br><span class="line">&#125;</span><br><span class="line">f2.logName() <span class="comment">// name  覆盖了原型链上的 logName() 函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> Foo()</span><br><span class="line">f3.name = <span class="string">'c'</span></span><br><span class="line">f3.logName() <span class="comment">// name is c  只覆盖了 Foo 上的 name</span></span><br></pre></td></tr></table></figure>
<h2 id="arguments-函数隐含的参数，是所有参数构成的一个类数组"><a href="#arguments-函数隐含的参数，是所有参数构成的一个类数组" class="headerlink" title="arguments 函数隐含的参数，是所有参数构成的一个类数组"></a><code>arguments</code> 函数隐含的参数，是所有参数构成的一个类数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">arguments</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="setTimeout-和-setInterval-两者的区别"><a href="#setTimeout-和-setInterval-两者的区别" class="headerlink" title="setTimeout 和 setInterval 两者的区别"></a><code>setTimeout</code> 和 <code>setInterval</code> 两者的区别</h2><ul>
<li><code>setTimeout</code> 是过一定时间之后执行 <code>function，</code> 然后终止</li>
<li><code>setInterval</code> 是每过一段时间之后执行 <code>function</code>，清除用 <code>clearInterval(id)</code> 的方法</li>
</ul>
<p><code>setTimeout</code> 与循环结合:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), i)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sat Dec 01 2018 16:37:48 GMT+0800 (中国标准时间) 5   这是第六行的 console.log()</span></span><br><span class="line"><span class="comment">// Sat Dec 01 2018 16:37:49 GMT+0800 (中国标准时间) 5</span></span><br><span class="line"><span class="comment">// Sat Dec 01 2018 16:37:49 GMT+0800 (中国标准时间) 5</span></span><br><span class="line"><span class="comment">// Sat Dec 01 2018 16:37:49 GMT+0800 (中国标准时间) 5</span></span><br><span class="line"><span class="comment">// Sat Dec 01 2018 16:37:49 GMT+0800 (中国标准时间) 5</span></span><br><span class="line"><span class="comment">// Sat Dec 01 2018 16:37:49 GMT+0800 (中国标准时间) 5</span></span><br></pre></td></tr></table></figure>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。</p>
<p><a href="https://yuchengkai.cn/docs/zh/frontend/#%E9%98%B2%E6%8A%96" target="_blank" rel="noopener">参考</a></p>
<ul>
<li>需求1：在滚动事件中需要做个复杂计算</li>
<li>需求2：实现一个按钮的防二次点击操作。</li>
</ul>
<p>尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，<br>不如将多次计算合并为一次计算，只在一个精确点做操作。</p>
<p>对于按钮防点击来说的实现：一旦我开始一个定时器，只要我定时器还在，<br>不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了。</p>
<p>对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，<br>如果小于需要的时间间隔，就会重新创建一个定时器，<br>并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数。</p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>防抖动和节流本质是不一样的。<br>防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要让 B 继承 A</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-绑定构造函数"><a href="#1-绑定构造函数" class="headerlink" title="1. 绑定构造函数"></a>1. 绑定构造函数</h3><p>使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    A.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-prototype-模式"><a href="#2-prototype-模式" class="headerlink" title="2. prototype 模式"></a>2. <code>prototype</code> 模式</h3><p>如果 <code>B</code> 的 <code>prototype</code> 对象，指向一个 <code>A</code> 的实例，那么所有 <code>B</code> 的实例，就能继承 <code>A</code> 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = <span class="keyword">new</span> A()</span><br><span class="line"><span class="comment">// 这一行是为了把 B 的构造函数重新指向 B</span></span><br><span class="line">B.prototype.constructor = B</span><br></pre></td></tr></table></figure>
<h3 id="3-直接继承-prototype"><a href="#3-直接继承-prototype" class="headerlink" title="3.直接继承 prototype"></a>3.直接继承 <code>prototype</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = A.prototype</span><br><span class="line"><span class="comment">// 这一行是为了把 B 的构造函数重新指向 B</span></span><br><span class="line">B.prototype.constructor = B</span><br></pre></td></tr></table></figure>
<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立 <code>A</code> 的实例了），比较省内存。缺点是 <code>B.prototype</code> 和 <code>A.prototype</code> 现在指向了同一个对象，那么任何对 <code>B.prototype</code> 的修改，都会反映到 <code>A.prototype</code> 。</p>
<p>这种做法有个问题，把 <code>A</code> 的构造函数也指向 <code>B</code> 了。</p>
<h3 id="利用空对象作为中介"><a href="#利用空对象作为中介" class="headerlink" title="利用空对象作为中介"></a>利用空对象作为中介</h3><p>由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。<br>git p<br>直接封装成一个 <code>extend</code> 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    Foo.prototype = Parent.prototype</span><br><span class="line">    Child.prototype = <span class="keyword">new</span> Foo()</span><br><span class="line">    Child.prototype.constructor = Child</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">extend(B, A)</span><br></pre></td></tr></table></figure>
<h3 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h3><p>把父对象的所有属性和方法，拷贝进子对象，实现继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = Parent.prototype</span><br><span class="line">    <span class="keyword">var</span> c = Child.prototype</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">        c[i] = p[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>js 语言是单线程，同一时间只能做一件事。<br>js 的任务分两种， 同步任务，异步任务。<br>同步任务进入主线程执行，形成执行栈，异步任务有了执行结果之后，就放入任务队列。<br>主线程的任务执行完之后，就会去执行任务里的任务。<br>不断重复，形成 event loop</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Kowal$ki</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kowal$ki</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
